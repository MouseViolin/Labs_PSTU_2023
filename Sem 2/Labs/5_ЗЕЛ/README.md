# Лабораторная работа №5
>[!IMPORTANT]
>Тема : "Функции и массивы"
>Цель: Организовать обработку массивов с использованием функций, научиться передавать массивы как параметры функций.

# Вариант №5

>Определить является ли матрица ортонормированной, т. е. такой, что скалярное произведение каждой пары различных строк равно 0, а скалярное произведение строки самой на себя равно 1.

# Блок-схема
![5_ЗЕЛ](https://github.com/MouseViolin/Labs_PSTU_2023/assets/129219043/63eb5e14-4b0b-4f1d-90a1-86b5d3375cb8)


# Код программы

```cpp
#include <iostream>
#include <cmath>

using namespace std;

//Функция sc_product проверяет скалярное произведение текущей строки со всеми в матрице(в том числе и с самой с собой)

int sc_product(int n, int str_arr, int col_arr, double arr[5][5]) {
    double sc = 0, sum = 0;
    for (int i = 0; i<str_arr; i++) {
        for (int j = 0; j < col_arr; j++) {
            sc += (round(arr[n][j]*100)/100)*(round(arr[i][j]*100)/100);
        }
        sum += sc;
        sc = 0;
//      На каждом проходе цикла, происходит сложение скалярных произведений с текущей строкой,
//        сумма которых (исходя из условия) должна быть равна 1
    }
    return sum;
}

int main() {
    srand(time_t(0));
    int str_arr, col_arr, sum = 0;
    
    cin >> str_arr;
    col_arr = str_arr;
//  Массив можно задавать и с помощью генератора случайных чисел или вручную
    double arr[5][5] = { {(1/sqrt(3)), (1/sqrt(3)), (1/sqrt(3))},
        {(1/sqrt(6)), (1/sqrt(6)), (1/sqrt(6))},
        {(1/sqrt(2)), 0, -(1/sqrt(2))} };
    for (int i = 0; i < str_arr; cout << endl, i++)
            for (int j = 0; j < str_arr;cout << arr[i][j] << " ", j++);
        
    for (int i = 0; i<str_arr; i++) {
        sum += sc_product(i, str_arr, col_arr, arr);

    }
//  Исходя из условий: если матрица ортогональна, то количество ортонормированных строк должно быть равно
//  числу строк в матрице
    if (sum == str_arr) {
        cout << "Матрица ортогональна" << endl;
    } else {cout << "Матрица не ортогональна" << endl;}
    
    return 0;
}

/*
 Входная матрица: arr[5][5] = { {(1/sqrt(3)), (1/sqrt(3)), (1/sqrt(3))},
                                {(1/sqrt(6)), (1/sqrt(6)), (1/sqrt(6))},
                                {(1/sqrt(2)),      0,      -(1/sqrt(2))} };
 Итог: Матрица ортогональна
 
 */

/*
 Входная матрица: arr[5][5] = { {0.6, -(0.8)},
                                {0.8,   0.6}};
 Итог: Матрица ортогональна
 */

/*
 Входная матрица: arr[5][5] = { {(2/3.), (2/3.),-(1/3.)},
                                {(2/3.),-(1/3.), (2/3.)},
                                {-(1/3.),(2/3.), (2/3.)}};
  Итог: Матрица ортогональна
 */

/*
 Входная матрица: arr[5][5] = { {4, 5,-3},
                                {2, 1, 1/2.},
                                {3, 7, 0}};
  Итог: Матрица не ортогональна
 */

```
